[{
  "tag": "P",
  "text": "This was just a few examples, but the understanding of this simple code can allow any programmer to take on the initially ominous world of mathematics. Of course, these methods can all be consolidated for efficiency and usually have a library method readily available. The point of writing these in simple code is to see how much sense they make when written out in the form of their true operations.",
  "translation": "这只是几个示例，但是对这种简单代码的理解可以使任何程序员承担起初不祥的数学世界。 当然，这些方法都可以合并以提高效率，并且通常具有易于使用的库方法。 用简单的代码编写这些代码的目的是查看以真实操作的形式写出它们时的意义。"
}, {
  "tag": "P",
  "text": "Continue the conversation with me on Twitter or LinkedIn!",
  "translation": "在Twitter或LinkedIn上继续与我对话！"
}, {
  "tag": "P",
  "text": "Sources",
  "translation": "资料来源"
}, {
  "tag": "P",
  "text": "[1]https://commons.wikimedia.org/wiki/File:Pure-mathematics-formulæ-blackboard.jpg",
  "translation": "[1]https://commons.wikimedia.org/wiki/File:Pure-mathematics-formulæ-blackboard.jpg"
}, {
  "tag": "H1",
  "text": "Understanding Mathematical Symbols with Code",
  "translation": "用代码了解数学符号"
}, {
  "tag": "H2",
  "text": "Summations, factorials, matrices and more are simple when we look at them with our favorite languages",
  "translation": "当我们用自己喜欢的语言查看求和，阶乘，矩阵等时，它们很简单"
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/max/60/1*ubAcgBoHgEjkEZdkjGWBjw.jpeg?q=20",
  "caption": "Source",
  "type": "image",
  "file": "1!ubAcgBoHgEjkEZdkjGWBjw.jpeg"
}, {
  "tag": "P",
  "text": "For anyone interested in pursuing a career or research in Machine Learning and Data Science, the day will come when it is time to move beyond the python libraries to follow curiosities into the math behind it all. This will typically take you to the vast, open collection of papers detailing how it all works. The deeper you go to understand the core mathematics, the closer you may come to the flash of insight to create a new method. Everything seems to be all right on the first paper until you come across something like this:",
  "translation": "对于任何有兴趣从事机器学习和数据科学事业或研究的人来说，是时候超越python库，追随好奇心进入所有数学背后的日子了。 通常，这将带您进入大量公开的论文集，详细说明其工作原理。 您对核心数学的理解越深入，您就越可能一见倾心就创建了一种新方法。 在您遇到类似以下内容之前，第一篇文章上的所有内容似乎都还不错："
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/max/60/1*0eEoY8QbkMSWZ3PC6rxiCA.png?q=20",
  "type": "image",
  "file": "1!0eEoY8QbkMSWZ3PC6rxiCA.png"
}, {
  "tag": "P",
  "text": "For anyone who has studied math for years or worked at the math level of Machine Learning, such an equation can be carefully parsed into meaning and code. For many others though, this may look like hieroglyphics. The truth is that it almost seems like the ancient math leaders chose the most interesting looking symbols to describe rather intuitive methods. The result: Equations and variables that look much more complex than they really are.",
  "translation": "对于已经学习数学多年或在机器学习的数学水平上工作的任何人，可以将这样的方程式仔细地解析为含义和代码。 但是对于许多其他人来说，这看起来像象形文字。 事实是，古代数学领袖似乎似乎选择了最有趣的外观符号来描述相当直观的方法。 结果是：方程和变量看起来比实际复杂得多。"
}, {
  "tag": "P",
  "text": "I’ve found that code can be used for more than writing programs, but also a globally agreed upon language to explain the complex. When I was learning the math behind everything Data Science, I always found that the best way to gain a universal understanding of math was to write code snippets to describe equations. Eventually, these symbols become understood to a point that they can almost be read as text in a typical paper. In this article, I hope to share some examples of how simple math can be when described with code!",
  "translation": "我发现代码不仅可以用于编写程序，还可以用于解释复杂性的全球通用语言。 当我学习所有数据科学背后的数学时，我总是发现，获得对数学的普遍理解的最佳方法是编写代码段来描述方程式。 最终，这些符号被理解为几乎可以在典型论文中将其理解为文本。 在本文中，我希望分享一些示例，说明用代码描述数学的简单性！"
}, {
  "tag": "H1",
  "text": "Summation and Product",
  "translation": "求和与乘积"
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/max/48/1*Jkz-mGx7b_8gwj2X2W_F0Q.png?q=20",
  "type": "image",
  "file": "1!Jkz-mGx7b_8gwj2X2W_F0Q.png"
}, {
  "tag": "P",
  "text": "The summation symbol is one of the most useful and commonly used symbols in iterative mathematics. Despite its complex design, the implementation is rather simple, yet incredibly useful.",
  "translation": "求和符号是迭代数学中最有用和最常用的符号之一。 尽管设计复杂，但是实现还是相当简单，但却非常有用。"
}, {
  "tag": "PRE",
  "text": "x = [1, 2, 3, 4, 5, 6]result = 0for i in range(6):    result += x[i]Output of print(result) -> 21",
  "translation": "x = [1、2、3、4、5、6]结果= 0，用于范围（6）中的i：结果+ = x [i]打印输出（结果）-> 21"
}, {
  "tag": "P",
  "text": "As seen above, all that this symbol represents is a for loop in the range of the number on top, starting from the number on the bottom. The variable set on the bottom becomes the index variable and any result per loop is added to an overall value. Less commonly, the following may be used:",
  "translation": "如上所示，此符号代表的所有内容都是从顶部的数字开始的for循环，在顶部的数字范围内。 在底部设置的变量将成为索引变量，并且每个循环的所有结果都将添加到总值中。 较不常见的是，可以使用以下方法："
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/max/46/1*HoOU4xaHuSDZDxqAXqSs9Q.png?q=20",
  "type": "image",
  "file": "1!HoOU4xaHuSDZDxqAXqSs9Q.png"
}, {
  "tag": "P",
  "text": "Typically called the Product Operator, this symbol functions in the same manner, but instead of adding each result they will be multiplied.",
  "translation": "通常称为乘积运算符，该符号以相同的方式起作用，但不是将每个结果相加，而是将它们相乘。"
}, {
  "tag": "PRE",
  "text": "x = [1, 2, 3, 4, 5, 1]result = 1for i in range(6):    result *= x[i]Output of print(result) -> 120",
  "translation": "x = [1、2、3、4、5、1]结果= 1，因为范围（6）中的i：结果* = x [i]打印输出（结果）-> 120"
}, {
  "tag": "H1",
  "text": "Factorial",
  "translation": "阶乘"
}, {
  "tag": "P",
  "text": "Factorial is the “!” which exists on almost any calculator. To many, this one may be a bit more obvious, but it is still worth it to write some code to understand the mechanics.",
  "translation": "阶乘是“！” 几乎所有计算器上都存在。 对许多人来说，这可能更明显一些，但是仍然值得编写一些代码以了解其原理。"
}, {
  "tag": "P",
  "text": "5! would be represented as:",
  "translation": "5！ 将表示为："
}, {
  "tag": "PRE",
  "text": "result = 1for i in range(1,6):    result *= iOutput of print(result) -> 120",
  "translation": "对于范围（1,6）中的i，结果= 1：结果* =打印输出（结果）-> 120"
}, {
  "tag": "H1",
  "text": "Conditional Brackets",
  "translation": "条件括号"
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/freeze/max/60/1*QOToiv5cYyuxtSx4S0q2WA.gif?q=20",
  "type": "image",
  "file": "1!QOToiv5cYyuxtSx4S0q2WA.gif"
}, {
  "tag": "P",
  "text": "Conditional brackets are used to divert the flow of an equation based on a set of conditions. For coders, this is simply the common “if” statement. The above conditional can be represented as:",
  "translation": "条件括号用于根据一组条件转移方程的流程。 对于编码人员，这只是常见的“ if”语句。 以上条件可以表示为："
}, {
  "tag": "PRE",
  "text": "i = 3y = [-2, 3, 4, 1]result = 0if i in y:    result = sum(y)elif i > 0:    result = 1else:    result = 0print(result) -> 6",
  "translation": "i = 3y = [-2、3、4、1]结果= 0，如果i in y：结果= sum（y）elif i> 0：结果= 1else：结果= 0print（结果）-> 6"
}, {
  "tag": "P",
  "text": "As seen above, the right notation of each row of the bracket dictates what each path should execute. I threw the extra “contains” symbol into each condition as well to add more insight. As seen above, we checked if the i value was in the y list. Recognizing that it was, we returned the sum of the array. If the i value had not been in the array we would have returned 0 or 1 based on the value.",
  "translation": "如上所示，括号中每一行的正确表示法规定了每个路径应执行的操作。 我还将多余的“包含”符号放入每个条件中，以增加更多的见解。 如上所示，我们检查了i值是否在y列表中。 认识到确实如此，我们返回了数组的总和。 如果i值不在数组中，我们将基于该值返回0或1。"
}, {
  "tag": "H1",
  "text": "Point Wise and Cartesian Matrix Multiplication",
  "translation": "点明智和笛卡尔矩阵乘法"
}, {
  "tag": "P",
  "text": "Finally, I wanted to quickly cover the operations which are typically done for any Data Scientist by their favorite language library — matrix multiplication. The easiest form to understand is the point wise operation. This is simply written as:",
  "translation": "最后，我想快速介绍一下任何数据科学家通常通过其喜欢的语言库（矩阵乘法）完成的操作。 最容易理解的形式是逐点操作。 简写为："
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/freeze/max/60/1*6E0BD5E_DqCpdROR7IAonQ.gif?q=20",
  "type": "image",
  "file": "1!6E0BD5E_DqCpdROR7IAonQ.gif"
}, {
  "tag": "P",
  "text": "Note the first requirement is that each matrix must have the same shape(ie # rows= & #Columns=)",
  "translation": "请注意，第一个要求是每个矩阵必须具有相同的形状（即＃rows =＆＃Columns =）"
}, {
  "tag": "P",
  "text": "The code for this looks as follows:",
  "translation": "此代码如下所示："
}, {
  "tag": "PRE",
  "text": "y = [[2,1],[4,3]]z = [[1,2],[3,4]]x = [[0,0],[0,0]]for i in range(len(y)):    for j in range(len(y[0])):        x[i][j] = y[i][j] * z[i][j]print(x) -> [[2, 2], [12, 12]]  ",
  "translation": "y = [[2,1]，[4,3]] z = [[1,2 ,, [3,4]] x = [[0,0]，[0,0]] len（y））：对于范围内的j（len（y [0]））：x [i] [j] = y [i] [j] * z [i] [j] print（x）-> [ [2，2]，[12，12]]"
}, {
  "tag": "P",
  "text": "Lastly let's take a look at a typical matrix multiplication process, most commonly used in Machine Learning. In complex terms, this operation finds the dot product of each primary row with each secondary column. The main take away from this is the the following requirement: assume [#rows, #columns] →matrices i x j requires #columns(i) == #rows(j) → with a final product of shape [#rows(i), #columns(j)]",
  "translation": "最后，让我们看一下机器学习中最常用的典型矩阵乘法过程。 用复杂的术语来说，此运算将找到每个主要行与每个次要列的点积。 这样做的主要目的是：假设[#rows，#columns]→矩阵ixj要求#columns（i）== #rows（j）→最终产品的形状为[#rows（i）， #columns（j）]"
}, {
  "tag": "P",
  "text": "This may seem confusing and my best suggestion would be to take a look at google images for some great visualizations of these requirements.",
  "translation": "这似乎令人困惑，我最好的建议是看一下Google图片，以直观了解这些要求。"
}, {
  "tag": "FIGURE",
  "image": "https://miro.medium.com/freeze/max/60/1*WRv85SjF3uyXdcb4i5xQZw.gif?q=20",
  "type": "image",
  "file": "1!WRv85SjF3uyXdcb4i5xQZw.gif"
}, {
  "tag": "P",
  "text": "The code for this equation looks as follows(using numpy dot method):",
  "translation": "该方程的代码如下（使用numpy点方法）："
}, {
  "tag": "PRE",
  "text": "y = [[1,2],[3,4]]z = [[2], [1]]# x has shape [2, 1]x = [[0], [0]]for i in range(len(y))    for j in range(len(z):        x[i][j] = np.dot(y[i], z[:, j])print(x) -> [[4],             [10]]",
  "translation": "y = [[1,2 ,, [3,4]] z = [[2]，[1]]＃x的形状为[2，1] x = [[0]，[0]] 范围（len（z）：x [i] [j] = np.dot（y [i]，z [:, j]）中的j的（len（y））print（x）-> [[4] ，[10]"
}, {
  "tag": "PRE",
  "text": "(本文翻译自Ian Rowan的文章《Understanding Mathematical Symbols with Code》，参考：https://towardsdatascience.com/understanding-mathematical-symbols-with-code-5aa0c542644)",
  "translation": "（本文翻译自Ian Rowan的文章《用代码理解数学符号》，参考：https：//towardsdatascience.com/understanding-mathematical-symbols-with-code-5aa0c542644）"
}]